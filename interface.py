from stl import mesh
from mpl_toolkits import mplot3d
from matplotlib import pyplot
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg, NavigationToolbar2QT as NavigationToolbar
from matplotlib.figure import Figure
import math
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QComboBox, QWidget, QApplication, QPushButton, QGridLayout, QLabel, QCheckBox, QInputDialog, QLineEdit, QFileDialog
from PyQt5 import QtCore, QtGui
import sys
import numpy as np
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
from PyQt5.QtCore import *
from PyQt5.QtGui import *
import matplotlib.animation as animation
import random
import rospy
from visualization.msg import DoorSensor
import os
import atexit
import signal
import subprocess
import multiprocessing
import pandas as pd
import rosbag
import uuid


#live vs recorded
live = 0

#pipeline queues 
#FSR Queue
queue = multiprocessing.Queue()
#Distance Queue 
distanceQueue = multiprocessing.Queue()
bagQueue = multiprocessing.Queue()

#buffers for graphs
buffer = []
sensor = [] 
time = []

# All subwindows generated by the application 
otherWindows =[]

# current process id generated by fork 
pid = 0


# kill other threads when on exit 
def clean():
    global pid
    os.kill(pid, signal.SIGKILL)


atexit.register(clean)


# class for storing the data from sensor_data topic 
class Sensors:
    def __init__(self, fsr1, fsr2, fsr3, fsr4, fsr5, fsr6, fsr7, fsr8, fsr9, fsr10, fsr11, fsr12, time):
        self.fsr1 = fsr1
        self.fsr2 = fsr2
        self.fsr3 = fsr3
        self.fsr4 = fsr4
        self.fsr5 = fsr5
        self.fsr6 = fsr6
        self.fsr7 = fsr7
        self.fsr8 = fsr8
        self.fsr9 = fsr9
        self.fsr10 = fsr10
        self.fsr11 = fsr11
        self.fsr12 = fsr12
        self.time = time
     



# Wrapper class for generating canvas in the application 
class CanvasFigure(FigureCanvasQTAgg):
    def __init__(self, parent=None, width=4, height=4, dpi=100):
        self.fig = Figure(figsize=(width, height), dpi=dpi)
        super(CanvasFigure, self).__init__(self.fig)
        self.axes = self.fig.add_subplot(111)
              

# class for openning a graph in a sep window 
class DifferentWindows(QtWidgets.QMainWindow):
    def __init__(self, p, t, status = [], index = -1, num = 0 ):
        super(QWidget, self).__init__()
        self.showMaximized()
        self.setWindowTitle('Distance Graph')
        w = Wrapper(p, status, t, index, num)
        self.setCentralWidget(w)


# class wrapper class with the selection of what graph to open and layout structure. 
# Used to setup interface 
class Wrapper(QtWidgets.QWidget):
    def __init__(self, p, status, t, index, num):
        super(QWidget, self).__init__()
        layout = QtWidgets.QVBoxLayout(self) 
        layout1 = QtWidgets.QHBoxLayout(self)

        self.setLayout(layout)
        layout.addStretch()
        layout.addLayout(layout1)
        layout.addStretch()
        if (t == 0):
            self.g = GraphDistance(p, index, num)
        if (t == 1):
            self.g = Graph(p, status, index, num)
        if (t == 2):
            
            self.g = graphImage(p, status, index, num)
        layout1.addStretch()
        layout1.addWidget(self.g)
        layout1.addStretch()
        


# canvas and controls for graping Distance against Time 
class GraphDistance(QtWidgets.QWidget):
    def __init__(self, p, index, num):
        self.parent = p
        super(QWidget, self).__init__()
        self.index = index
        if num == 1: 
            self.height = 700
            self.width = 1000
        elif num == 2:
            self.height = 550
            self.width = 600
        elif num == 0:
            self.width = 1200
            self.height = 800 
        else:
            self.width = 500
            self.height = 400
        
        self.setFixedWidth(self.width)
        self.setFixedHeight(self.height)
        button = QPushButton()
        button.setText("Export Path")
        
        button.setFixedWidth(120)
        button.setFixedHeight(30)
        self.layout = QtWidgets.QVBoxLayout(self) 
        self.layout1 =  QtWidgets.QHBoxLayout(self)
        buttonBack = QPushButton()
        buttonBack.setText("Remove")
        buttonBack.setStyleSheet("background-color: red;")
        buttonBack.setFixedWidth(120)
        buttonBack.setFixedHeight(30)
        buttonNewWindow = QPushButton()
        buttonNewWindow.setText("New Window")
        buttonNewWindow.setFixedWidth(120)
        buttonNewWindow.setFixedHeight(30)
        buttonBack.clicked.connect(lambda:self.parent.goBackToSelection(self.index))
        buttonNewWindow.clicked.connect(lambda:self.openInNewWindow())
        self.canvas = CanvasFigure(self, width=5, height=4, dpi=100)
        self.canvas.fig.suptitle('Distance Graph', fontsize=14)
        #self.layout1.addWidget(button)
        if num != 0:
            self.layout.addLayout(self.layout1)
        self.layout.addWidget(self.canvas)
        self.layout1.addStretch()
        self.layout1.addWidget(buttonNewWindow)
        self.layout1.addWidget(buttonBack)
        
        self.setLayout(self.layout)


   

        # Setup a timer to trigger the redraw by calling update_plot.
        self.timer = QtCore.QTimer()
        self.timer.setInterval(1000)
        self.timer.timeout.connect(self.update_plot)
        self.timer.start()
        


    
   

    # update plot in either  live - 0 or recorded - 1 mode 
    def update_plot(self):
        if live == 0:
            global buffer 
            buffer = []
            global time 
            time = [] 
            i = 0 
            if len(self.parent.bagData) != 0: 
                while  i <= len(self.parent.bagData) -1 and (self.parent.bagData[i][1]-self.parent.t_start).to_sec() < self.parent.currentValue:
                    d = self.parent.bagData[i][0]
                    buffer = buffer + [d.tof]
                    time = time + [d.current_time.to_sec()]
                    i = i+1

        else: 
            global buffer
            global time
            global distanceQueue
            while distanceQueue.empty() == 0: 
                d = distanceQueue.get()
                buffer = buffer + [d.tof]
                time = time + [d.current_time.to_sec()]
               
                

            
        self.canvas.axes.cla() 
        if len(buffer) != 0: 
            df = pd.DataFrame(buffer, time, columns = ["Distance"])
            df.plot(ax = self.canvas.axes)
        self.canvas.draw()


    # open the widget in a new window 
    def openInNewWindow(self):
        global otherWindows
        otherWindows.append(DifferentWindows(self.parent, 0))


# add data from message to queues with preimplemented mutex 
def update_live(n):
    global queue
    global distanceQueue 
    global bagQueue
    queue.put(n)
    distanceQueue.put(n)
    bagQueue.put(n)
   
    
# Widget to select item placed on the testbed
class Items(QtWidgets.QWidget):
    def __init__(self, p, statusArray, index, num):
        super(QWidget, self).__init__()
        self.statusArray = statusArray
        self.parent = p
        self.index = index
        if num == 1: 
            self.height = 700
            self.width = 1000
        elif num == 2:
            self.height = 550
            self.width = 600 
        elif num == 0:
            self.width = 1200
            self.height = 800 
        else:
            self.width = 500
            self.height = 400
        self.setFixedWidth(self.width)
        self.setFixedHeight(self.height)
        button = QPushButton()
        button.setText("Export Path")
        button.setFixedWidth(120)
        button.setFixedHeight(30)
        buttonBack = QPushButton()
        buttonBack.setText("Remove")
        buttonBack.setStyleSheet("background-color: red;")
        buttonBack.setFixedWidth(120)
        buttonBack.setFixedHeight(30)
        buttonBack.clicked.connect(lambda:self.parent.goBackToSelection(self.index))
        buttonNewWindow = QPushButton()
        buttonNewWindow.setText("New Window")
        buttonNewWindow.setFixedWidth(120)
        buttonNewWindow.setFixedHeight(30)
        buttonNewWindow.clicked.connect(lambda:self.openInNewWindow(self.parent))
        self.layout = QtWidgets.QVBoxLayout(self) 
        self.layout1 =  QtWidgets.QHBoxLayout(self)
        
        if num != 0:
            self.layout.addLayout(self.layout1)
        self.layout.addWidget(ObjectChoice(self.parent))
        self.layout1.addStretch()
        self.layout1.addWidget(buttonNewWindow)
        self.layout1.addWidget(buttonBack)
        self.setLayout(self.layout)


# all possible objects on the testbed 
class ObjectChoice(QtWidgets.QWidget):
    def __init__(self, p):
        super(QWidget, self).__init__()
        self.parent = p
        self.layout = QtWidgets.QVBoxLayout(self) 
        self.layout1 =  QtWidgets.QHBoxLayout(self)
        self.layout2 =  QtWidgets.QHBoxLayout(self)
        self.setLayout(self.layout)
        self.layout.addLayout(self.layout1)
        self.layout.addLayout(self.layout2)
        self.layout1.addWidget(self.parent.currentItems[0])
        self.layout1.addWidget(self.parent.currentItems[1])
        self.layout2.addWidget(self.parent.currentItems[2])
        self.layout2.addWidget(self.parent.currentItems[3])
        
       


# Graph fsr data against time using canvas
class Graph(QtWidgets.QWidget):
    def __init__(self, p, statusArray, index, num):
        self.statusArray = statusArray
        self.parent = p
        super(QWidget, self).__init__()
        self.index = index
        if num == 1: 
            self.height = 700
            self.width = 1000
        elif num == 2:
            self.height = 550
            self.width = 600 
        elif num == 0:
            self.width = 1200
            self.height = 800 
        else:
            self.width = 500
            self.height = 400
        self.setFixedWidth(self.width)
        self.setFixedHeight(self.height)
        button = QPushButton()
        button.setText("Export Path")
       
        button.setFixedWidth(120)
        button.setFixedHeight(30)
       
        self.layout = QtWidgets.QVBoxLayout(self) 
        self.layout1 =  QtWidgets.QHBoxLayout(self)
        buttonBack = QPushButton()
        buttonBack.setText("Remove")
        buttonBack.setStyleSheet("background-color: red;")
        buttonBack.setFixedWidth(120)
        buttonBack.setFixedHeight(30)
        
        buttonBack.clicked.connect(lambda:self.parent.goBackToSelection(self.index))
        buttonNewWindow = QPushButton()
        buttonNewWindow.setText("New Window")
        buttonNewWindow.setFixedWidth(120)
        buttonNewWindow.setFixedHeight(30)
        buttonNewWindow.clicked.connect(lambda:self.openInNewWindow())
        
        self.canvas = CanvasFigure(self, width=5, height=4, dpi=100)
        self.canvas.fig.suptitle('FSR Graph', fontsize=14)
        #self.layout1.addWidget(button)
        if num != 0:
            self.layout.addLayout(self.layout1)
        self.layout.addWidget(self.canvas)
        self.layout1.addStretch()
        self.layout1.addWidget(buttonNewWindow)
        self.layout1.addWidget(buttonBack)
        
        
        self.setLayout(self.layout)
        
        
            

        # Setup a timer to trigger the redraw by calling update_plot.
        self.timer = QtCore.QTimer()
        self.timer.setInterval(100)
        self.timer.timeout.connect(self.update_plot)
        self.timer.start()
        


    def openInNewWindow(self):
        global otherWindows
        otherWindows.append(DifferentWindows(self.parent, 1, self.statusArray))
     

    
    


    def update_plot(self):
        global sensor   
        global queue 
        a = []         
        time = []  
        names = []
        i = 0
        if live == 0:
            sensor = []
            if len(self.parent.bagData) != 0: 
                while i <= len(self.parent.bagData) -1 and (self.parent.bagData[i][1]-self.parent.t_start).to_sec() < self.parent.currentValue:
                    d = self.parent.bagData[i][0]
                    sensor = sensor + [Sensors(d.fsr1, d.fsr2, d.fsr3, d.fsr4, d.fsr5, d.fsr6, d.fsr7,
                                            d.fsr8, d.fsr9, d.fsr10, d.fsr11, d.fsr12, d.current_time)]
                    i = i+1
        
           
        else: 
            while queue.empty() == 0: 
                d = queue.get()
                sensor = sensor + [Sensors(d.fsr1, d.fsr2, d.fsr3, d.fsr4, d.fsr5, d.fsr6, d.fsr7,
                                        d.fsr8, d.fsr9, d.fsr10, d.fsr11, d.fsr12, d.current_time)]

            
        l = len(sensor)
        bound = min(l, 20)
       
        inner = []
        for i in range (bound):
            inner = []
            time.append(sensor[l-bound+i].time.to_sec())
            if self.statusArray[0] == 1:
                inner = inner + [sensor[l-bound+i].fsr1]
            if self.statusArray[1] == 1:
                inner = inner + [sensor[l-bound+i].fsr2]
            if self.statusArray[2] == 1:
                inner = inner + [sensor[l-bound+i].fsr3]
            if self.statusArray[3] == 1:
                inner = inner + [sensor[l-bound+i].fsr4]
            if self.statusArray[4] == 1:
                inner = inner + [sensor[l-bound+i].fsr5]
            if self.statusArray[5] == 1:
                inner = inner + [sensor[l-bound+i].fsr6]
            if self.statusArray[6] == 1:
                inner = inner + [sensor[l-bound+i].fsr7]
            if self.statusArray[7] == 1:
                inner = inner + [sensor[l-bound+i].fsr8]
            if self.statusArray[8] == 1:
                inner = inner + [sensor[l-bound+i].fsr9]
            if self.statusArray[9] == 1:
                inner = inner + [sensor[l-bound+i].fsr10]
            if self.statusArray[10] == 1:
                inner = inner + [sensor[l-bound+i].fsr11]
            if self.statusArray[11] == 1:
                inner = inner + [sensor[l-bound+i].fsr12]
            a.append(inner) 
        if self.statusArray[0] == 1:
            names = names + ["FSR1"]
        if self.statusArray[1] == 1:
            names = names + ["FSR2"]
        if self.statusArray[2] == 1:
            names = names + ["FSR3"]
        if self.statusArray[3] == 1:
            names = names + ["FSR4"]
        if self.statusArray[4] == 1:
            names = names + ["FSR5"]
        if self.statusArray[5] == 1:
            names = names + ["FSR6"]
        if self.statusArray[6] == 1:
            names = names + ["FSR7"]
        if self.statusArray[7] == 1:
            names = names + ["FSR8"]
        if self.statusArray[8] == 1:
            names = names + ["FSR9"]
        if self.statusArray[9] == 1:
            names = names + ["FSR10"]
        if self.statusArray[10] == 1:
            names = names + ["FSR11"]
        if self.statusArray[11] == 1:
            names = names + ["FSR12"]
        self.canvas.axes.cla()  
        
        if  len(inner) != 0:
            df = pd.DataFrame(a, time, columns = names)
            df.plot(ax = self.canvas.axes)
        self.canvas.draw()


class graphImage(QWidget):
    def __init__(self, p, statusArray, index, num):
        super(QWidget, self).__init__()
        self.visibleButtons = statusArray
        self.index = index 
        self.parent = p 
        if num == 0:
            self.parent.otherWindows.append(self)
        if num == 1: 
            self.height = 700
            self.width = 1000
        elif num == 2:
            self.height = 550
            self.width = 600 
        elif num == 0:
            self.width = 1200
            self.height = 800 
        else:
            self.width = 500
            self.height = 400
        self.setFixedWidth(self.width)
        self.setFixedHeight(self.height)
        self.fig = Figure()
        buttonBack = QPushButton()
        buttonBack.setText("Remove")
        buttonBack.setStyleSheet("background-color: red;")
        buttonBack.setFixedWidth(120)
        buttonBack.setFixedHeight(30)
        buttonBack.clicked.connect(lambda:self.parent.goBackToSelection(self.index))
        buttonNewWindow = QPushButton()
        buttonNewWindow.setText("New Window")
        buttonNewWindow.setFixedWidth(120)
        buttonNewWindow.setFixedHeight(30)
        buttonNewWindow.clicked.connect(lambda:self.openInNewWindow())
        self.canvas = FigureCanvas(self.fig)
        self.axes = self.fig.add_subplot(111, projection='3d')
        self.layout = QtWidgets.QVBoxLayout(self) 
        buttonLaout = QtWidgets.QHBoxLayout(self) 
        self.controlLayot = QtWidgets.QHBoxLayout(self) 
        self.text = QCheckBox("Display Labels",self)
        self.text.setChecked(True)
        self.text.stateChanged.connect(self.toggleText)
        self.controlLayot.addStretch()
        self.controlLayot.addWidget(buttonNewWindow)
        self.controlLayot.addWidget(buttonBack)
        if num != 0:
            self.layout.addLayout(self.controlLayot)
        self.layout.addWidget(self.canvas)
        self.layout.addLayout(buttonLaout)
        buttonLaout.addStretch()
        buttonLaout.addWidget(self.text)
        self.marks = QCheckBox("Display Marks",self)
        buttonLaout.addStretch()
        self.marks.setChecked(True)
        self.marks.stateChanged.connect(self.toggleMarks)
        buttonLaout.addWidget(self.marks)
        buttonLaout.addStretch()
        self.your_mesh = mesh.Mesh.from_file('./stl_meshes/Main.stl')
        self.meshArray = [] 
        self.sensors = []
        self.texts = []
        
        for i in range (12):
            self.meshArray.append(mesh.Mesh.from_file('./stl_meshes/sensor' + str(i+1) + '.stl'))
            self.sensors.append(mplot3d.art3d.Line3DCollection(self.meshArray[i].vectors, colors=(1,0,0,1), facecolors=(1,0,0,1), alpha=1, zorder=1, visible=False))
            self.axes.add_collection3d(self.sensors[i])
            self.texts.append(self.axes.text3D(self.meshArray[i].vectors[0][1][0],self.meshArray[i].vectors[0][1][1],self.meshArray[i].vectors[0][1][2],  "sensor #" + str(i+1),  visible=False))
            
        self.mainOjbect = mplot3d.art3d.Line3DCollection(self.your_mesh.vectors,colors=(0,0,0,1),  facecolors='gray', alpha=0.15, linewidths=0.2, zorder=2, visible=True)
        self.axes.add_collection3d(self.mainOjbect)
        scale = self.your_mesh.points.flatten()
        self.axes.auto_scale_xyz(scale*0.7, scale*0.7, scale*0.7)
        self.axes.set_axis_off()
        
        self.toggleMarks(QtCore.Qt.Checked)
        self.toggleText(QtCore.Qt.Checked)


    def setvisibleButtons(self, v):
        self.visibleButtons = v


    def toggleText(self, state):
        if (state == QtCore.Qt.Checked):
            for i in range (12):
                if (self.visibleButtons[i] == 1):
                    self.showMesh(i)
        else: 
            for i in range (12):
                self.hideText(i)
                self.canvas.draw()


    def toggleMarks(self, state):
        if (state == QtCore.Qt.Checked):
            for i in range (12):
                if (self.visibleButtons[i] == 1):
                    self.showMesh(i)
        else: 
            for i in range (12):
                 self.sensors[i].set_visible(False)
                 self.canvas.draw()


    def showMesh(self, index):
        if (self.marks.isChecked()):
            self.sensors[index].set_visible(True)
        if (self.text.isChecked()):
            self.showText(index)
        self.canvas.draw()


    def hideText(self, index):
        self.texts[index].set_visible(False)


    def showText(self,index):
        self.texts[index].set_visible(True)


    def hideMesh(self, index):
        self.sensors[index].set_visible(False)
        self.hideText(index)
        self.canvas.draw()

    
    def openInNewWindow(self):
        global otherWindows
        otherWindows.append(DifferentWindows(self.parent, 2, self.visibleButtons))
  




    
class Menu(QWidget): 
    def __init__(self, ap = 1, arm = 1, mode = 1, parent = None):
        self.parent = parent
        self.mode = mode
        super(QWidget, self).__init__()
        self.ap = ap 
        self.arm = arm
        self.comboBox = QComboBox(self)
        self.comboBox.addItem("Mode: Live")
        self.comboBox.addItem("Mode: Recorded")

        if mode == 1:
            self.comboBox.setCurrentText("Mode: Live")
        else:
            self.comboBox.setCurrentText("Mode: Recorded")
 
        self.comboBox.currentIndexChanged.connect(lambda: self.change())

        filler = QLabel('', self)
        filler.resize(200, 70)
        self.setFixedHeight(650)
        self.setFixedWidth(250)
        layout = QtWidgets.QVBoxLayout(self) 
        sublayout = QtWidgets.QVBoxLayout(self) 
        self.createApLabel()
        self.createArmLabel()
        layout.addWidget(self.comboBox)
        layout.addWidget(self.ALabel)
        layout.addWidget(self.Arm)
        
        layout.addStretch()
        
        self.buttonArray = []
        self.statusArray = []
        for i in range (12):
            self.buttonArray.append(QPushButton("FSR " + str(i+1)))
            self.statusArray.append(0)
        self.buttonArray.append(QPushButton("Distance Sensor"))
        self.statusArray.append(0)
        for i in range (13):
            layout.addWidget(self.buttonArray[i])
            layout.addStretch()
        layout.addWidget(filler)
        
    def change(self):
        content = self.comboBox.currentText()
        if content == 'Mode: Live':
            self.parent.parent.changeMode(1)
        else:
            clean()
            self.parent.parent.changeMode(2)


    def createApLabel(self):
        self.ALabel = QComboBox(self)
        self.ALabel.addItem("Apparatus: Drawer")
        self.ALabel.addItem("Apparatus: Door")
        self.ALabel.addItem("Apparatus: Test Bed")
        if self.ap == 1:
            self.ALabel.setCurrentText("Apparatus: Drawer")
        elif self.ap == 2:
            self.ALabel.setCurrentText("Apparatus: Door")
        else: 
            self.ALabel.setCurrentText("Apparatus: Test Bed")
        self.ALabel.currentIndexChanged.connect(self.changeApparatus)
    

    def changeApparatus(self, index): 
        self.parent.parent.changeApparatus(index+1)

    def changeArm(self, index):
        self.parent.parent.changeArm(index+1)


    def createArmLabel(self):
        self.Arm = QComboBox(self)
        self.Arm.addItem("Arm: Kinova Jaco2")
        self.Arm.addItem("Arm: Thor Arm")
        if self.arm == 1:
            self.Arm.setCurrentText("Arm: Kinova Jaco2")
        else: 
            self.Arm.setCurrentText("Arm: Thor Arm")
        self.Arm.currentIndexChanged.connect(self.changeArm)
     

    
class Add(QWidget):
    def __init__(self, p, index, num):
        super(QWidget, self).__init__()
        self.parent = p
        self.index = index
        if num == 1: 
            self.height = 700
            self.width = 1000
        elif num == 2:
            self.height = 550
            self.width = 600 
        else:
            self.width = 500
            self.height = 400
        self.setFixedWidth(self.width)
        self.setFixedHeight(self.height)
        self.c1 = QPushButton("Distance Graph")
        self.c2 = QPushButton("FSR Graph")
        self.c3 = QPushButton("3D Model")
        self.c4 = QPushButton("RViz Visualization")
        self.c6 = QPushButton("Select Test Item")
        self.c5 = QPushButton("Back")
        self.c5.setFixedWidth(80)
        self.c5.setFixedHeight(25)
        self.c5.setStyleSheet("background-color: red;")
        self.layout = QtWidgets.QHBoxLayout(self)
        self.layout1 = QtWidgets.QVBoxLayout()
        self.layout2 = QtWidgets.QHBoxLayout(self)
        self.setLayout(self.layout)
        self.layout.addStretch()
        self.layout.addLayout(self.layout1)
        self.button = QPushButton("", self)
        self.button.setStyleSheet("border-image: url(./src/plus.png);")
        self.button.setFixedWidth(64)
        self.button.setFixedHeight(64)
        self.button.clicked.connect(lambda:self.switchToS())
        self.c1.clicked.connect(lambda:self.parent.addDistanceGraph(self.index))
        self.c2.clicked.connect(lambda:self.parent.addFSRGraph(self.index))
        self.c3.clicked.connect(lambda:self.parent.addModel(self.index))
        self.c4.clicked.connect(lambda:self.parent.addRviz(self.index))
        self.c5.clicked.connect(lambda:self.parent.goBack(self.index))
        self.c6.clicked.connect(lambda:self.parent.addItems(self.index))
        self.layout1.addWidget(self.button)
        self.layout.addStretch()


    def switchToS(self): 
        self.button.deleteLater()
        self.layout1.addStretch()
        self.layout1.addWidget(self.c1)
        self.layout1.addWidget(self.c2)
        self.layout1.addWidget(self.c3)
        self.layout1.addWidget(self.c4)
        if self.parent.apparatus == 3:
            self.layout1.addWidget(self.c6)
        self.layout1.addLayout(self.layout2)
        
        self.layout2.addWidget(self.c5)
        self.layout1.addStretch()


class Window(QWidget):
    def __init__(self, ap, arm, mode, num = 4, parent = None):
        super(QWidget, self).__init__()
        self.started = 0
        #self.showMaximized()
        self.bag  = None
        self.bagData = []
        self.parent = parent
        self.maxValue = 100
        self.currentValue = 0
        self.num = num
        self.otherWindows = [] 
        self.widgetArray = [0,0,0,0]
        self.currentItems = []
        self.initItems()
        self.layoutArray =  [0,0,0,0]
        self.apparatus = ap 
        self.arm = arm
        global live
        
        if mode == 1:
            live = 1
        else:
            live = 0

        
    
        self.mode = mode 
        self.setWindowTitle('3dMesh')
        self.Main = QtWidgets.QVBoxLayout(self)
        self.layout = QtWidgets.QHBoxLayout(self)
        self.layout2 = QtWidgets.QHBoxLayout(self)
        self.layout3 = QtWidgets.QHBoxLayout(self)
        if self.num == 4:
            self.vLayout1 = QtWidgets.QVBoxLayout(self)
            self.vLayout2 = QtWidgets.QVBoxLayout(self)
        for i in range(num):
            self.layoutArray[i] = QtWidgets.QHBoxLayout(self)
        self.setLayout(self.Main)
        self.ap = ap 
        self.arm = arm
        self.menu = Menu(ap, arm, mode, self)
        for i in range(num):
            self.widgetArray[i] = Add(self, i, self.num)
        self.Main.addLayout(self.layout)
        self.layout.addWidget(self.menu) 
        if self.num == 4:
            self.layout.addLayout(self.vLayout1)
            self.layout.addLayout(self.vLayout2)
            self.vLayout1.addLayout(self.layoutArray[0])
            self.vLayout1.addLayout(self.layoutArray[1])
            self.vLayout2.addLayout(self.layoutArray[2])
            self.vLayout2.addLayout(self.layoutArray[3])
        elif (self.num == 2): 
            self.layout.addLayout(self.layoutArray[0])
            self.layout.addLayout(self.layoutArray[1])
        else: 
            self.layout.addLayout(self.layoutArray[0])
        self.Main.addLayout(self.layout2)
        
        for i in range(num):
            self.layoutArray[i].addWidget(self.widgetArray[i])
        
       
       # self.initLabels()
        self.menu.buttonArray[0].clicked.connect(lambda:self.triggerAnimation(0))
        self.menu.buttonArray[1].clicked.connect(lambda:self.triggerAnimation(1))
        self.menu.buttonArray[2].clicked.connect(lambda:self.triggerAnimation(2))
        self.menu.buttonArray[3].clicked.connect(lambda:self.triggerAnimation(3))
        self.menu.buttonArray[4].clicked.connect(lambda:self.triggerAnimation(4))
        self.menu.buttonArray[5].clicked.connect(lambda:self.triggerAnimation(5))
        self.menu.buttonArray[6].clicked.connect(lambda:self.triggerAnimation(6))
        self.menu.buttonArray[7].clicked.connect(lambda:self.triggerAnimation(7))
        self.menu.buttonArray[8].clicked.connect(lambda:self.triggerAnimation(8))
        self.menu.buttonArray[9].clicked.connect(lambda:self.triggerAnimation(9))
        self.menu.buttonArray[10].clicked.connect(lambda:self.triggerAnimation(10))
        self.menu.buttonArray[11].clicked.connect(lambda:self.triggerAnimation(11))
        self.menu.buttonArray[12].clicked.connect(lambda:self.triggerAnimation(12))
        
        if self.menu.mode == 1: 
            Start = QPushButton(self)
            Start.setText("Run")
            Start.clicked.connect(lambda:self.startReading())
            Stop = QPushButton(self)
            Stop.setText("Stop")
            Stop.clicked.connect(lambda:self.stopReading())
            Start.setFixedHeight(30)
            Start.setFixedWidth(150)
            Stop.setFixedHeight(30)
            Stop.setFixedWidth(150)
            self.layout2.addStretch()
            self.layout2.addWidget(Start)
            self.layout2.addWidget(Stop)
            self.layout2.addStretch()
        else: 
            self.timer = QtCore.QTimer()
            self.timer.setInterval(100)
            self.timer.timeout.connect(self.startTimer)
            
            self.progress = QtWidgets.QProgressBar(self)
            self.progress.setMaximum(self.maxValue)
            self.progress.setValue(self.currentValue)
            self.layout2.addStretch()
            self.layout2.addWidget(self.progress)
            self.layout2.addStretch()
            self.Main.addLayout(self.layout3)
            self.Start = QPushButton(self)
            self.Start.setText("Play")
            self.Start.clicked.connect(lambda:self.swapButtonText())
            self.Left = QPushButton(self)
            self.Left.setText("<<")
            self.Left.clicked.connect(lambda:self.decreasebyFive())
            self.Right = QPushButton(self)
            self.Right.setText(">>")
            self.Right.clicked.connect(lambda:self.increaseByFive())
            self.playStatus = 0
            self.layout3.addStretch()
            self.layout3.addWidget(self.Left)
            self.layout3.addWidget(self.Start)
            self.layout3.addWidget(self.Right)
            self.layout3.addStretch()



    def initItems(self): 
        b1 = QPushButton("objectSelection")
        b1.setFixedWidth(150)
        b1.setFixedHeight(150)
        b1.setText("Object 1")
        b1.setStyleSheet("background-color: white;")
        b2 = QPushButton("objectSelection")
        b2.setFixedWidth(150)
        b2.setFixedHeight(150)
        b2.setText("Object 1")
        b2.setStyleSheet("background-color: white;")
        b3 = QPushButton("objectSelection")
        b3.setFixedWidth(150)
        b3.setFixedHeight(150)
        b3.setText("Object 3")
        b3.setStyleSheet("background-color: white;")
        b4 = QPushButton("objectSelection")
        b4.setFixedWidth(150)
        b4.setFixedHeight(150)
        b4.setText("Object 4")
        b4.setStyleSheet("background-color: white;")
        self.currentItems.append(b1)
        self.currentItems.append(b2)
        self.currentItems.append(b3)
        self.currentItems.append(b4)


        b1.clicked.connect(lambda:self.changeSelection(b1))
        b2.clicked.connect(lambda:self.changeSelection(b2))
        b3.clicked.connect(lambda:self.changeSelection(b3))
        b4.clicked.connect(lambda:self.changeSelection(b4))



    def changeSelection(self, button):
        for i in self.currentItems: 
            i.setStyleSheet("background-color: white;")
        button.setStyleSheet("background-color: lightgreen;")

    def increaseByFive(self):
        increase = (self.total_time/100)*5
        self.currentValue = self.currentValue + increase
        if self.currentValue > self.total_time:
            self.currentValue = self.total_time
        self.progress.setValue(self.currentValue)

    def startReading(self):
        if self.started == 0: 
            self.started = 1
            global pid
            pid = os.fork()
            if pid == 0:
                self.readData()


    def stopReading(self):
        self.started = 0
        global bagQueue
        print(bagQueue)
        
        fileName = str(uuid.uuid4())
        if self.parent.exPath == None:
            export = "../rosbag_records"
        else: 
            export = self.parent.exPath
        self.bag = rosbag.Bag(str(export)+ "/" + str(fileName), 'w')
        while bagQueue.empty() == 0:
            data = bagQueue.get()
            self.writeToBag(data)

        self.bag.close()
        clean()
        

    def onRead(self, data):
        update_live(data)
        



    def writeToBag(self, data):
        msg = DoorSensor()
        msg.current_time = data.current_time
        msg.tof  = data.tof
        msg.fsr1 = data.fsr1
        msg.fsr2 = data.fsr2
        msg.fsr3 = data.fsr3
        msg.fsr4 = data.fsr4
        msg.fsr5 = data.fsr5
        msg.fsr6 = data.fsr6
        msg.fsr7 = data.fsr7
        msg.fsr8 = data.fsr8
        msg.fsr9 = data.fsr9
        msg.fsr10 = data.fsr10
        msg.fsr11 = data.fsr11
        msg.fsr12 = data.fsr12
        msg.fsr_contact_1
        msg.fsr_contact_2
        self.bag.write("sensor_data",  msg, msg.current_time)
        

    
    def readData(self):
        rospy.init_node('interface', anonymous=True)
        rospy.Subscriber("sensor_data", DoorSensor, self.onRead)
        rospy.spin()




    def decreasebyFive(self):
        increase = (self.total_time/100)*5
        self.currentValue = self.currentValue - increase
        if (self.currentValue < 0):
            self.currentValue = 0
        self.progress.setValue(self.currentValue)


    def startTimer(self):
        self.currentValue = self.currentValue + 0.1
        if (self.currentValue >= self.total_time):
            self.swapButtonText()
        self.progress.setValue(self.currentValue)
    




    def openFileNameDialog(self):
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        fileName, _ = QFileDialog.getOpenFileName(self,"QFileDialog.getOpenFileName()", "","All Files (*);;Python Files (*.py)", options=options)
        if fileName:
            
            self.bag  = rosbag.Bag('../rosbag_records/test.bag', 'r')
            self.t_start = rospy.Time(self.bag.get_start_time())
            t_end   = rospy.Time(self.bag.get_end_time())
            self.total_time = (t_end - self.t_start).to_sec()
            self.bagData = []
            for topic, msg, t in self.bag.read_messages(topics=['sensor_data']):
                self.bagData.append([msg, t])
                
            
            self.progress.setMaximum(self.total_time)
            self.progress.setValue(0)
            return 1
        return 0


    def swapButtonText(self):
        if self.playStatus == -1: 
            if (self.openFileNameDialog()): 
                self.Start.setText("Play")
                self.playStatus = 0; 

        elif self.playStatus == 0:
            if self.bag  == None and self.parent.imPath != None:
                self.bag  = rosbag.Bag(self.parent.imPath, 'r')
                self.t_start = rospy.Time(self.bag.get_start_time())
                t_end   = rospy.Time(self.bag.get_end_time())
                
                self.total_time = (t_end - self.t_start).to_sec()
                self.bagData = []
                for topic, msg, t in self.bag.read_messages(topics=['sensor_data']):
                    self.bagData.append([msg, t])
                self.progress.setMaximum(self.total_time)
                print(self.total_time)
                self.progress.setValue(0)
                
                    
            if self.bag != None: 
                self.playStatus = 1
                self.timer.start()
                self.Start.setText("Stop")
        else: 
            self.playStatus = 0
            self.timer.stop()
            self.Start.setText("Play")

    def goBack(self, index):
        self.widgetArray[index].deleteLater()
        self.widgetArray[index] = Add(self, index, self.num)
        self.layoutArray[index].addWidget(self.widgetArray[index])


    def addDistanceGraph(self, index):
        self.widgetArray[index].deleteLater()
        self.widgetArray[index] = GraphDistance(self, index, self.num)
        self.layoutArray[index].addWidget(self.widgetArray[index])


    def addFSRGraph(self, index):
        self.widgetArray[index].deleteLater()
        self.widgetArray[index] = Graph(self, self.menu.statusArray, index, self.num)
        self.layoutArray[index].addWidget(self.widgetArray[index])


    def addRviz(self, index):
        pass

    def addItems(self, index):
        self.widgetArray[index].deleteLater()
        for i in range (len(self.widgetArray)):
            if isinstance(self.widgetArray[i], Items):
                self.widgetArray[i].deleteLater()
                self.widgetArray[i] = Add(self, i, self.num)
                self.layoutArray[i].addWidget(self.widgetArray[i])
        self.widgetArray[index] = Items(self, self.menu.statusArray, index, self.num)
        self.layoutArray[index].addWidget(self.widgetArray[index])

    def addModel(self, index):
        self.widgetArray[index].deleteLater()
        self.widgetArray[index] = graphImage(self, self.menu.statusArray, index, self.num)
        self.layoutArray[index].addWidget(self.widgetArray[index])


    def goBackToSelection(self, index):
        self.widgetArray[index].deleteLater()
        self.widgetArray[index] = Add(self, index, self.num)
        self.layoutArray[index].addWidget(self.widgetArray[index])


    def triggerAnimation(self, index):
        if index == 12: 
            if self.menu.statusArray[index] == 0:   
                self.menu.buttonArray[index].setStyleSheet("background-color : lightgreen")
                self.menu.statusArray[index] = 1
            else: 
                self.menu.statusArray[index] = 0
                self.menu.buttonArray[index].setStyleSheet("background-color : light gray")
            return 

        
        if self.menu.statusArray[index] == 0:
            for i in range(len(self.widgetArray)):
                if isinstance(self.widgetArray[i], graphImage):
                    self.widgetArray[i].showMesh(index) 
            self.menu.statusArray[index] = 1
            
            self.menu.buttonArray[index].setStyleSheet("background-color : lightgreen")
        else: 
            for i in range(len(self.widgetArray)):
                if isinstance(self.widgetArray[i], graphImage):
                    self.widgetArray[i].hideMesh(index) 
            self.menu.buttonArray[index].setStyleSheet("background-color : light gray")
            self.menu.statusArray[index] = 0
        for i in range(len(self.widgetArray)):
            if isinstance(self.widgetArray[i], graphImage): 
                self.widgetArray[i].setvisibleButtons(self.menu.statusArray)


    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Space:
            self.image.showPoly()
        elif event.key() == Qt.Key_Enter:
            self.image.clear()

  

if __name__ == '__main__':
    app = QApplication(sys.argv)
    main = Window(1,1)
    main.resize(860, 640)
    main.show()
    sys.exit(app.exec_())

